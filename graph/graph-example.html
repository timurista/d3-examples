<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <title>Line chart from CSV using d3.js</title>
    <script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>
    <script type="text/javascript" src="./data.js"></script>
    <style></style>
  </head>
  <body>
    <div id="bar-chart"></div>
    <div id="chart-area"></div>

    <script type="text/javascript">
      // DATA
      console.log("DATA", gData);
      var data = gData;

      var colors = x => ({ "-1": "red", "1": "green", "0": "lightblue" }[x]);
      // bar chart

      var barsize = width / data.length;
      var margin = { left: 100, right: 10, top: 10, bottom: 100 };
      var width = 800 - margin.left - margin.right;
      var height = 400 - margin.top - margin.bottom;

      var svg = d3
        .select("#bar-chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);
      // need scales
      // domain to output range
      // 0, 828
      // var ymax = data.map(x => x.value).reduce((a, b) => Math.max(a, b));
      // var ymin = data.map(x => x.value).reduce((a, b) => Math.min(a, b));

      // y invert flips it

      // data.forEach(d => {
      //   d.height = +d.height;
      // });

      var x = d3
        .scaleTime()
        .domain([d3.max(data, d => d.date), d3.min(data, d => d.date)])
        .range([width, 0]);
      // .paddingInner(0.2)
      // .paddingOuter(0.2);

      console.log("MAXED DATA", gData, d3.max(data, d => d.totals));
      var y = d3
        .scaleLinear()
        .domain([0, d3.max(data, d => d.totals)])
        .range([height, 0]);
      // .range([data[0].date, data[data.length - 1].date]);

      var xAxis = d3
        .axisBottom(x)
        .ticks(20)
        .tickFormat(d3.timeFormat("%b %e, %Y"));

      var yAxis = d3.axisLeft(y);

      console.log(y);

      var g = svg
        .append("g")
        .attr(
          "transform",
          "translate(" + margin.left + ", " + margin.top + ")"
        );

      g.append("g")
        .attr("class", "x-axis")
        .attr("transform", "translate(0, " + height + ")")
        .call(xAxis)
        .selectAll("text")
        .attr("y", "10")
        .attr("x", "-5")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-40)");

      g.append("g")
        .attr("class", "y-axis")
        .call(yAxis);

      var area = d3
        .area()
        .x(function(d) {
          return x(d.date);
        })
        .y0(height)
        .y1(function(d, i) {
          return y(d.value);
        })
        .curve(d3.curveBasis);

      // define the line
      var valueline = d3
        .line()
        .x(function(d) {
          return x(d.date);
        })
        .y(function(d, i) {
          return y(d.value);
        })
        .curve(d3.curveBasis);

      const positives = data.map(x => ({ date: x.date, value: x.positives }));
      const negatives = data.map(x => ({ date: x.date, value: x.negatives }));
      const neturals = data.map(x => ({ date: x.date, value: x.neutrals }));
      const totals = data.map(x => ({ date: x.date, value: x.totals }));
      const cumulativeSentiment = data.map(x => ({
        date: x.date,
        value: x.cumulativeSentiment
      }));

      // console.log(positives);
      const generateArea = (g, data, color) => {
        g.append("path")
          .data([data])
          .attr("class", "area")
          .attr("d", area)
          .attr("fill", color)
          .attr("fill-opacity", "0.3");

        g.append("path")
          .data([data])
          .attr("class", "line")
          .attr("d", valueline)
          .attr("fill-opacity", "0")
          .attr("stroke", color)
          .attr("stroke-opacity", "0.8");
      };

      generateSentimentLine = (g, data) => {
        var ySent = d3
          .scaleLinear()
          .domain([d3.min(data, d => d.value), d3.max(data, d => d.value)])
          .range([height, 0]);
        var sentimentValueLine = d3
          .line()
          .x(function(d) {
            return x(d.date);
          })
          .y(function(d, i) {
            return ySent(d.value);
          })
          .curve(d3.curveBasis);

        var defs = g.append("defs");

        var gradient = defs
          .append("linearGradient")
          .attr("id", "svgGradient")
          .attr("x1", "0%")
          .attr("x2", "0%")
          .attr("y1", "100%")
          .attr("y2", "0%");

        gradient
          .append("stop")
          .attr("class", "start")
          .attr("offset", "0%")
          .attr("stop-color", "#FF7474")
          .attr("stop-opacity", 1);

        gradient
          .append("stop")
          .attr("class", "end")
          .attr("offset", "100%")
          .attr("stop-color", "#8CE984")
          .attr("stop-opacity", 1);

        g.append("path")
          .data([data])
          .attr("class", "sentiment-line")
          .attr("d", sentimentValueLine)
          .attr("fill-opacity", "0")
          .attr("stroke-opacity", "0.8")
          .attr("stroke-width", "3px")
          .attr("stroke", "url(#svgGradient)");
        // .attr(
        //   "transform",
        //   "translate(0, -" + (height + margin.bottom) / 2 + ")"
        // );
      };

      generateArea(g, positives, "green");
      generateArea(g, negatives, "red");
      generateArea(g, neturals, "blue");
      generateArea(g, totals, "lightgrey");

      generateSentimentLine(g, cumulativeSentiment);

      // var rects = g
      //   .selectAll("rect")
      //   .data(data)
      //   .enter()
      //   .append("rect")
      //   .attr("y", (d, i) => {
      //     console.log(d);
      //     return y(d.value);
      //   })
      //   .attr("x", (d, i) => {
      //     return x(d.date);
      //   })
      //   .attr("width", 2)
      //   .attr("height", d => {
      //     return height - y(d.value);
      //   })
      //   .attr("fill", d => {
      //     return colors(d.normalizedSent);
      //   });

      // CIRCLES
      // var svg = d3
      //   .select("#chart-area")
      //   .append("svg")
      //   .attr("width", 2000)
      //   .attr("height", 400);

      // var circles = svg.selectAll("circle").data(data);

      // circles
      //   .enter()
      //   .append("circle")
      //   .attr("cx", function(d, i) {
      //     // console.log(d, i);
      //     return i * 50 + 25;
      //   })
      //   .attr("cy", function(d, i) {
      //     // console.log(d, i);
      //     return 25;
      //   })
      //   .attr("r", function(d, i) {
      //     // console.log(d, i);
      //     var x = d.normalizedSent.toString();
      //     // console.log({ "-1": "red", "1": "green", "0": "lightblue" }[x]);
      //     return d.value + 20;
      //   })
      //   .attr("fill", d => colors(d.normalizedSent));
    </script>
  </body>
</html>
